**递归：计算思维的核心**

# 引言

人类对这个世界的认识是从特例到普遍，从具体到抽象，从简单到复杂的，是一个`递推`（`Iterative`）的过程。这人类中固有的认知与思维方式令我们可以轻易的理解具体的事物，但同时却限制了我们的抽象能力和大局视觉。

而计算机执行任务的方式（可以称之为“计算思维”）与人类正好相反，计算思维是一种自顶向下，由全局到局部的抽象设计，往往是一个`递归`（`Recursive`）的过程。递归是计算思维中的重要概念，通过递归，可以将复杂问题分解为更小的子问题，便于计算机从全局进入到局部，以分治的思想去简化地求解问题。

若将人类的思维方式当做正向是为，那么计算机则使用的“逆向思维”方式。

# 递归思想

试想一下求解 $5!$ 的方式，如果按照正向思维，我们可以通过 $5 \times 4 \times 3 \times 2 \times 1$ 来求解。而如果使用递归思想，我们可以将 $5!$ 分解为 $5 \times 4!$，然后再将 $4!$ 分解为 $4 \times 3!$，以此类推，直到 $1!$ 为止。

通过求解 $5!$ 的两种方式，我们可以了解递归求解问题的基本思路：

- 确认`基本情况`(`Base Case`)，即最简单的、可以直接得出结果的情况。比如 $1! = 1$。
- 确认`递归情况`(`Recursive Case`)，即将问题分解为更小的子问题，并调用自身求解这些子问题。比如 $n!$ = $n \times (n-1)!$。

递归的本质就是调用自身，便于解决分治结构的问题。每个递归调用将问题拆解成更小的子问题，并在达到递归基条件时终止递归。

通过求解 $5!$ 这样简单的问题我们可能还无法感受到递归的妙处，下面我们以复杂一些的示例来展示递归思想的优势。

# 抢 20 游戏

> 两个人做游戏，轮流从 1 和 2 中挑选一个数字，并计算所有被选到数字的总和，当数字的总和正好为 20 时，当前出手的人获胜。问题是如何设定策略可以保证一定能赢？

这个问题正向思维的解法是通过穷举所有可能的情况，然后找到必胜策略，但要穷举所有情况是相当困难的。但是如果采用递归思维，将这个问题分解一下，问题可能会变得相当简单。

我们试想一下，如果想要保证最后一轮轮到自己时，一定能使数字的总和为 20，那么在上一轮轮到自己时数字的总和一定要是 17，因为只有在 17 的基础上，我们可以保障无论对手选择 1 还是 2，我们都可以使数字的总和为 20。

同理，要保障自己可以得到总和为 17 的结果，那么在上上轮轮到自己时数字的总和一定要是 14；以此类推，我们可以得到一个规律，即在轮到自己时，数字的总和一定要是 20 的倍数减去 3 的倍数。最终我们可以得出，只要我们能先抢到 $2 + 3 \times n$ 的总和数，我们就一定能赢，比如我们首轮首次出手就抢到 2。

这就是递归思维的妙处，通过分析问题的结构，我们可以找到问题的关键规律，只要在上一轮我们抢到了差 3 的总和数就能赢得游戏，在此基础上可以将问题拆解成更简单的子问题，保障每一轮都能得到差 3 的总和数，我们只需要关照当前简单的子问题，就能，从而设计出必胜策略。

而递归思维的解法则是通过分析问题的结构，找到规律，从而设计出必胜策略。

# 栈式调用

递归过程通常伴随着栈式调用，每个递归调用创建新的栈帧，直至达到基条件并开始回退。栈式调用是控制递归调用过程中的数据和操作流的基础数据结构。

在程序执行过程中，函数调用会使用一种称为“调用栈”（call stack）的数据结构。每次函数调用时，会在栈顶压入一个新的栈帧（stack frame），其中包含该函数的局部变量和返回地址。函数执行完毕后，这个栈帧会从栈顶弹出，程序继续执行之前的代码。

## 递归思想在降低多项式次数中的应用

考虑降低多项式次数的问题，以下是这方面的一些常见应用：

1. 归并排序 (Merge Sort) 和 快速排序 (Quick Sort)：

   - 归并排序：通过递归地将数组拆分成两半，再合并已经排序的子数组，原本的 O(n^2)复杂度可以降低到 O(n log n)。
   - 快速排序：通过递归地选择基准并对数组进行分区，同样将复杂度从 O(n^2)降低到平均情况下的 O(n log n)。

2. 矩阵乘法的 Strassen 算法：

   - 传统的矩阵乘法为 O(n^3)，而通过 Strassen 算法，可以将其细分为七个递归计算，降低复杂度到约 O(n^2.81)。

3. Fibonacci 数列计算：

   - 直接递归计算 Fibonacci 数列的复杂度为指数级别 O(2^n)，而通过带有记忆术（Memoization）的递归或动态规划可以将其降到线性时间 O(n)。

## 示例：降低 Fibonacci 数列的计算复杂度

### 直接递归 (O(2^n))

```python
def fibonacci(n):
    if n <= 1:
        return n
    else:
        return fibonacci(n-1) + fibonacci(n-2)
```

### 动态规划 (O(n))

```python
def fibonacci_dp(n):
    if n <= 1:
        return n
    fib = [0] * (n + 1)
    fib[1] = 1
    for i in range(2, n + 1):
        fib[i] = fib[i - 1] + fib[i - 2]
    return fib[n]

# 测试
print(fibonacci_dp(10))  # Output: 55
```

## 递归优化要点

1. 解决重复子问题：如动态规划和记忆化。
2. 树的深度和广度：分治法通过递归树的方法，将问题分解成更小的子问题，从而减少计算量。
3. 合并步骤的优化：像归并排序的合并步骤，可以通过合理设计数据结构和算法来最大化减少中间计算。

## 递归与迭代的比较

尽管递归有时非常简洁易懂，但每次递归调用都会消耗栈空间，存在风险。因此，在实际开发中，特别是对于大规模数据，可能会更倾向于使用迭代以避免栈溢出问题。

递归思想在计算机科学中被广泛应用，通过将复杂问题分解为更小的部分并递归求解，可以有效地降低时间复杂度和优化性能。这也是许多高效算法背后的核心思想。

# 分治算法（$n\log{n}$）

分治算法（Divide and Conquer）是一种通过将问题递归地分解成若干个规模更小但类型相同的子问题，分别解决这些子问题，再将它们的结果合并来得到原问题的解的方法。这种方法经常用于需要将复杂问题化简的场景中，并且在一些经典算法中，比如归并排序和快速排序中，都有着广泛的应用。

## 分治算法的核心思想

1. 分解（Divide）：将原问题分解成若干个规模更小的子问题。
2. 解决（Conquer）：递归地解决这些子问题。如果子问题足够小，用直接方法解决。
3. 合并（Combine）：将子问题的结果合并起来，得到原问题的解。

## 分治算法的一般形式

通过分治算法解决问题的一般步骤可以表示为：

1. 定义基本情况（Base Case）：即当问题规模足够小时，直接解决。
2. 划分问题（Divide）：将问题划分为更小的子问题。
3. 求解子问题（Conquer）：递归地求解子问题。
4. 合并结果（Combine）：将子问题的解合并获得原问题的解。

## 两个著名的分治算法例子：归并排序和快速排序

### 归并排序 (Merge Sort)

归并排序将数组分成两半，递归地进行排序，然后合并这两个有序的部分。归并排序的时间复杂度是 $O(n \log n)$。

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result

# 测试
arr = [12, 11, 13, 5, 6, 7]
print("归并排序结果:", merge_sort(arr))
```

### 快速排序 (Quick Sort)

快速排序选择一个基准值（pivot），然后将数组分割为两个部分，左边部分小于基准值，右边部分大于基准值。然后递归地对这两个部分进行排序。快速排序的平均时间复杂度是 $O(n \log n)$。

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)

# 测试
arr = [3, 6, 8, 10, 1, 2, 1]
print("快速排序结果:", quick_sort(arr))
```

## 时间复杂度分析

分治算法的时间复杂度可以通过递归树（Recurrence Tree）或主定理（Master Theorem）来分析。对于归并排序和快速排序，它们的时间复杂度均为 $O(n \log n)$，其中：

- $n$ 是原问题的规模。
- $\log n$ 是将问题不断分割成更小的子问题的次数。

具体来说，对归并排序：

1. 分解问题的次数是 $\log n$。
2. 每次合并的时间复杂度是 $O(n)$。

因此，总的时间复杂度是 $O(n \log n)$。

## 优缺点

优点：

- 效率高：对于大多数情况，分治策略能大大提高算法的效率。
- 易于实现：分治算法思想清晰，通常简洁而富有逻辑性。

缺点：

- 空间复杂度高：递归调用可能会使用较多的栈空间，特别是对于空间复杂度不太优化的实现。
- 分割不平衡：在某些情况下，尤其是快速排序，如果选取的基准值不合适，可能导致分割不平衡，这会影响算法效率。

总之，分治算法是一种强大而通用的方法，能够有效地降低问题的复杂度，尤其是在处理大规模数据时。

# 逆向思维（自顶向下，摆脱递推，跳出递归）

逆向思维是一种从问题的最终目标开始，逐步倒退推导出解决方案的算法设计方法。相比于自底向上的递推，逆向思维通常采用自顶向下的方式，通过反向分析来找到简化和优化问题的路径。

## 自顶向下的方法

自顶向下的方法是从问题的顶层开始，根据问题的结构逐步将其分解成更小的子问题。常见的方法包括递归和分治法，它们都遵循自顶向下的策略。

- 递归：通过函数调用自身来解决更小的子问题，直到达到基本情况（base case）。
- 分治法：将问题分解为独立的子问题，分别解决这些子问题，再将它们的结果合并。

## 摆脱递推

递推（Iteration）是自底向上的方法，通过逐步从基本情况开始，建立更复杂的结果。逆向思维则通过分析问题的最终状态，推导出更简单的状态，可以有效地避免重复计算和复杂的中间状态。

## 跳出递归

尽管递归是强大的工具，但它有时会导致栈溢出或性能问题。跳出递归可以通过以下几种方法来实现：

- 记忆化（Memoization）：缓存已解决的子问题的结果，以避免重复计算，从而优化递归算法。
- 动态规划：将递归问题转化为迭代问题，通过表格存储中间结果，自底向上求解。
- 利用数据结构优化递归：比如使用栈或队列来显式模拟递归过程。

## 逆向思维的示例：动态规划中的最短路径问题

问题：给定一个二维网格，每个格子有一个非负权值，找到从起点（左上角）到终点（右下角）的最小路径和。

逆向思维解决方案：

1. 目标：我们要从终点回推到起点。
2. 状态转移：设 `dp[i][j]` 表示到达格子 (i, j) 的最小路径和，那么：

   - 如果从上方来：`dp[i][j] = dp[i-1][j] + grid[i][j]`
   - 如果从左方来：`dp[i][j] = dp[i][j-1] + grid[i][j]`
   - 综合以上两点，我们有：`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`

3. 边界条件：起点 `dp[0][0] = grid[0][0]`。

完整代码如下：

```python
def min_path_sum(grid):
    if not grid or not grid[0]:
        return 0

    rows, cols = len(grid), len(grid[0])
    dp = [[0] * cols for _ in range(rows)]

    dp[0][0] = grid[0][0]

    for i in range(1, rows):
        dp[i][0] = dp[i-1][0] + grid[i][0]

    for j in range(1, cols):
        dp[0][j] = dp[0][j-1] + grid[0][j]

    for i in range(1, rows):
        for j in range(1, cols):
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]

    return dp[rows-1][cols-1]

# 测试
grid = [
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1]
]
print("最小路径和:", min_path_sum(grid))  # 输出: 7
```

## 逆向思维的其他示例

1. 最长公共子序列（LCS）：从两个字符串的末尾开始，倒推到两个字符串的开头，逐步确认最长公共子序列。
2. 背包问题：从背包的最大容量开始，逐步倒推出最优解。

## 应用场景

- 动态规划问题：逆向思维通过状态转移方程，推导并记录每个子问题的解。
- 路径规划问题：从目标点倒推到起点，有时比从起点逐步探索更为高效。
- 递归优化：通过分析递归调用栈，寻找并优化可能的重复计算。

逆向思维是一种强大的算法设计策略，通过从目标倒推问题，能够有效地简化问题结构，避免重复计算。在实际应用中，结合具体问题特性，逆向思维与动态规划、记忆化等方法往往能够高效地求解复杂问题。
