布隆过滤器：大数据量下的快速存在性判断

> Prompt: 关于 “哈希表” 与 “布隆过滤器”，你知道哪些信息？
>
> Prompt: 请简要介绍一下 “哈希表” 和 “布隆过滤器” 分别的原理和应用场景，给出 Python 模拟实现。

# 哈希表

哈希表（Hash Table）是一种数据结构，它通过哈希函数将键映射到存储桶或槽中，以便快速查找和插入。

## 基本概念

哈希表通过一个哈希函数将键映射到存储位置。理想情况下，不同的键通过哈希函数映射到不同的位置，这样可以在常数时间内进行查找、插入和删除操作。

当两个键被哈希函数映射到同一个位置（即产生冲突）时，常用的冲突解决方法有链地址法（通过链表处理冲突）和开放地址法（通过探测下一个位置进行存储）。

- 时间复杂度：查找、插入和删除操作的平均时间复杂度为 \(O(1)\)。
- 冲突处理：常见的冲突处理方法有链地址法（Chaining）和开放地址法（Open Addressing）。
- 应用场景：适用于需要高效查找、插入和删除操作的应用，例如内存缓存、符号表、字典等。

使用 Python 模拟实现：

```python
class HashTable:
    def __init__(self, size=100):
        self.size = size
        self.table = [[] for _ in range(size)]

    def _hash(self, key):
        return hash(key) % self.size

    def insert(self, key, value):
        index = self._hash(key)
        for kvp in self.table[index]:
            if kvp[0] == key:
                kvp[1] = value
                return
        self.table[index].append([key, value])

    def search(self, key):
        index = self._hash(key)
        for kvp in self.table[index]:
            if kvp[0] == key:
                return kvp[1]
        return None

    def delete(self, key):
        index = self._hash(key)
        for kvp in self.table[index]:
            if kvp[0] == key:
                self.table[index].remove(kvp)
                return True
        return False

# 使用示例
ht = HashTable()
ht.insert("key1", "value1")
print(ht.search("key1"))  # 输出: value1
ht.delete("key1")
print(ht.search("key1"))  # 输出: None
```

# 布隆过滤器

`布隆过滤器`（Bloom Filter）是一种空间效率高的概率型数据结构，用于检测一个元素是否属于集合。

## 基本概念

布隆过滤器使用一个位数组和多个哈希函数来确定元素是否可能存在于集合中。插入元素时，将元素通过多个哈希函数计算得到的多个索引位置设为 1。检查元素时，仅需检查多个索引位置的位是否全为 1。如果有任意一位为 0，说明元素肯定不在集合中；如果全为 1，说明元素可能在集合中（但存在误判的可能）。

- 时间复杂度：插入和查询操作的时间复杂度均为 \(O(k)\)，其中 \(k\) 是哈希函数的数量。
- 特点：
  - 误判率：允许有一定的误判率（即可能会错误地认为某个元素在集合中）。
  - 无删除功能：标准的布隆过滤器不支持删除操作。
- 应用场景：用于快速判断某元素是否存在于大规模集合中，适用于需要高效存储和查询但能容忍少量误判的场景，如缓存、垃圾邮件过滤、区块链、网络黑名单过滤、大规模数据处理等。

使用 Python 模拟实现：

```python
import mmh3
from bitarray import bitarray

class BloomFilter:
    def __init__(self, size=1000, hash_count=3):
        self.size = size
        self.hash_count = hash_count
        self.bit_array = bitarray(size)
        self.bit_array.setall(0)

    def _hashes(self, item):
        return [mmh3.hash(item, i) % self.size for i in range(self.hash_count)]

    def add(self, item):
        for index in self._hashes(item):
            self.bit_array[index] = 1

    def lookup(self, item):
        return all(self.bit_array[index] for index in self._hashes(item))

# 使用示例
bf = BloomFilter()
bf.add("item1")
print(bf.lookup("item1"))  # 输出: True
print(bf.lookup("item2"))  # 输出: False
```

# 结语

哈希表适用于精确查找，而布隆过滤器适用于在大数据量下的快速存在性判断。
